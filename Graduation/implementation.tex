\chapter{実装}

{\system} は MacRuby で記述された Mac 用の IME であり，ソースが 500 行
程度とコンパクトであるにもかかわらず，他の IME に見られない機能を実装し
ており，本論文のような実験も容易である．

\section{MacRubyによる実装}

MacRuby は，Mac OS 用のアプリケーションを開発するために拡張された Ruby 実
行環境であり，Mac OS の Objective-C ライブラリを Ruby で扱うことが出来る．
%
{\system} では，Mac OS のIMEフレームワークである
InputMethodKit Framework を MacRuby から呼び出すことによって
基本的なIME の機能を実装している．

% \subsection{{\system}が受け取るキー入力}
\section{修飾キーの扱い}

エディタが編集機能のために用いる，ControlやCommandなどの修飾キーはIMEが
ハンドルしないのが普通であるが，{\system}では、一部のファンクションキー
と修飾キーの入力を受け取り，共通化されたテキスト編集操作を実現している．

{\system} のように，修飾キーの一部をハンドルする実装を行った場合，修飾
キーの入力はエディタに送出されないため，
%エディタが同じキー入力を編集操作に割り当てていても、機能衝突が起こることはない。
エディタが同じキー入力を編集操作の一部に割り当てている場合，それを利用することは出来なくなる．

\section{テキストデータの取得}

ブロック移動やインデントの処理といったテキスト編集の機能を，
あらゆるテキストエリアで行うためには，
テキストエリアに入力されている全文をIMEが取得する必要があり，
InputMethodKitはこの機能を備えていない．
%
{\system} では，
ブロック移動やインデントのコマンドが入力された際に，
Mac OS に実装されている，
テキストエリアの全文を選択状態にするコマンドを
AppleScriptにより送信している．

\subsection{Mac OSX上での実装}

Mac OSでは，
多くのアプリケーションにおいてテキストエリアはNSTextField Class のオブジェクトとして実装されており，
このNSTextFieldに対してテキスト編集や入力の操作を行うためのNSTextInput Protocolが存在する．
このプロトコルには標準の実装としてCommand+Aキーによる全文選択の機能が備わっている．

{\system}では，
このキー入力をAppleScriptによりテキストエリアに送信することにより，
テキストエリアの全文を選択状態にしている．
%
{\system}では，
NSTextInputの標準実装であるCommand+Cキーによる全文コピーの機能をAppleScriptにより送信することで，
Mac OSのクリップボードにテキストエリアの全文を保存し，
それをInputMethodKit Frameworkが読み込むことで，
テキストエリアの全文をIMEが取得している．
%

\section{実装手法の問題点}

しかし，このような手法で実装できる編集機能や，
IMEとしてのパフォーマンスには問題がある．
たとえば，対象とするテキストエリア自体がNSTextField Classを利用していない場合や，
対象とするテキストエリアがテキストの全選択やコピーに割り当てるキーバインドを変更している場合，
テキストエリアの全文を取得することが出来ない場合があり，
{\system}の持つ編集機能は有効に機能しない．
%
また、どこまでの編集機能をエディタやテキストエリアから切り離し，
どれだけの拡張性を持たせることができるか，という点において，
IMEの層での実装には問題がある．
各国語入力のための枠組みであるIMEは，
テキストエリアよりも先にユーザのキー入力をハンドルすることができるが，
エディタが想定するキー入力を横取りして、エディタの機能をを打ち消す実装になる可能性がある．
%
前述したDynamic Macroの例のように、
編集操作をマクロ化して行うことは多くあるので，
IMEとテキストエリアとの間に，テキスト編集のための枠組みを用意し，
機能拡張が容易に可能なOSとAPI設計のレベルでの実装の修正が求められる．

